use std::marker::PhantomData;

use dendro_ast::{ast::*, token, token_stream::*};
use dendro_span::{span::*, symbol::*, ident::*};

use crate::imp::{Unspanned::*, *};

grammar<'a>(cx: &'a DiagCx);

extern {
    type Location = Pos;
    type Error = dendro_error::DiagnosticBuilder<'a>;

    enum Unspanned {
        "delim" => Delimited(<token::Delimiter>, <TokenStream>),

        "=" => Single(token::Eq),
        "<" => Single(token::Lt),
        "<=" => Single(token::Le),
        "==" => Single(token::EqEq),
        "!=" => Single(token::Ne),
        ">=" => Single(token::Ge),
        ">" => Single(token::Gt),
        "&&" => Single(token::AndAnd),
        "||" => Single(token::OrOr),
        "!" => Single(token::Not),
        "~" => Single(token::Tilde),
        "`" => Single(token::BackQuote),
        "\\" => Single(token::BackSlash),

        "+" => Single(token::BinOp(token::Plus)),
        "-" => Single(token::BinOp(token::Minus)),
        "*" => Single(token::BinOp(token::Star)),
        "/" => Single(token::BinOp(token::Slash)),
        "%" => Single(token::BinOp(token::Percent)),
        "^" => Single(token::BinOp(token::Caret)),
        "&" => Single(token::BinOp(token::And)),
        "|" => Single(token::BinOp(token::Or)),
        "<<" => Single(token::BinOp(token::Shl)),
        ">>" => Single(token::BinOp(token::Shr)),

        "+=" => Single(token::BinOpEq(token::Plus)),
        "-=" => Single(token::BinOpEq(token::Minus)),
        "*=" => Single(token::BinOpEq(token::Star)),
        "/=" => Single(token::BinOpEq(token::Slash)),
        "%=" => Single(token::BinOpEq(token::Percent)),
        "^=" => Single(token::BinOpEq(token::Caret)),
        "&=" => Single(token::BinOpEq(token::And)),
        "|=" => Single(token::BinOpEq(token::Or)),
        "<<=" => Single(token::BinOpEq(token::Shl)),
        ">>=" => Single(token::BinOpEq(token::Shr)),

        "@" => Single(token::At),
        "." => Single(token::Dot),
        ".." => Single(token::DotDot),
        "..." => Single(token::DotDotDot),
        "..=" => Single(token::DotDotEq),
        "," => Single(token::Comma),
        ";" => Single(token::Semi),
        ":" => Single(token::Colon),
        "::" => Single(token::ColonColon),
        "->" => Single(token::RArrow),
        "<-" => Single(token::LArrow),
        "=>" => Single(token::FatArrow),
        "#" => Single(token::Pound),
        "$" => Single(token::Dollar),
        "?" => Single(token::Question),
        "'" => Single(token::SingleQuote),

        "_" => Single(token::Ident(kw::UNDERSCORE, false)),
        "forall" => Single(token::Ident(kw::FORALL, false)),
        "exists" => Single(token::Ident(kw::EXISTS, false)),
        "where" => Single(token::Ident(kw::WHERE, false)),
        "let" => Single(token::Ident(kw::LET, false)),
        "pub" => Single(token::Ident(kw::PUB, false)),
        "static" => Single(token::Ident(kw::STATIC, false)),
        "unsafe" => Single(token::Ident(kw::UNSAFE, false)),
        "default" => Single(token::Ident(kw::DEFAULT, false)),
        "const" => Single(token::Ident(kw::CONST, false)),
        "mut" => Single(token::Ident(kw::MUT, false)),
        "move" => Single(token::Ident(kw::MOVE, false)),
        "return" => Single(token::Ident(kw::RETURN, false)),
        "in" => Single(token::Ident(kw::IN, false)),
        "if" => Single(token::Ident(kw::IF, false)),
        "else" => Single(token::Ident(kw::ELSE, false)),
        "loop" => Single(token::Ident(kw::LOOP, false)),
        "while" => Single(token::Ident(kw::WHILE, false)),
        "break" => Single(token::Ident(kw::BREAK, false)),
        "continue" => Single(token::Ident(kw::CONTINUE, false)),
        "for" => Single(token::Ident(kw::FOR, false)),
        "match" => Single(token::Ident(kw::MATCH, false)),
        "leaf" => Single(token::Ident(kw::LEAF, false)),
        "try" => Single(token::Ident(kw::TRY, false)),

        "literal" => Single(token::Literal(<token::Lit>)),
        "ident" => Single(token::Ident(<Symbol>, <bool>)),
        "lifetime" => Single(token::Lifetime(<Symbol>)),
        "doc" => Single(token::DocComment(<token::CommentKind>, <AttrStyle>, <Symbol>)),
    }
}

// ------------------------------------------
// Identifiers

Ident: Ident = {
    <lo:@L> <ident:"ident"> <hi:@R> =>? ident::parse_ident(cx, Span::new(lo, hi), ident),
}

Lifetime: Lifetime = {
    <lo:@L> <lifetime:"lifetime"> <hi:@R> => Lifetime {
        id: DUMMY_ID,
        ident: Ident::new(lifetime, Span::new(lo, hi)),
    },
}

Mutability: Mutability = {
    "const"? => Mutability::kw(kw::CONST),
    "mut" => Mutability::kw(kw::MUT),
    "move" => Mutability::kw(kw::MOVE),
    "#" <ident:Ident> => Mutability { id: DUMMY_ID, ident },
}

// ------------------------------------------
// Expressions

Where: Vec<P<Expr>> = {
    "where" <first:Expr> <next:("," Expr)*> "," => {
        [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect()
    },
}

Prerequisites: Prerequisites = {
    <lo:@L>
        "forall" <first:Ident> <next:("," Ident)*>
        <w:Where?> "::"
    <hi:@R> => {
        Prerequisites {
            id: DUMMY_ID,
            forall: [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect(),
            where_clause: w.unwrap_or_default(),
            span: Span::new(lo, hi),
        }
    }
}

UnOpKind: UnOpKind = {
    "*" => UnOpKind::Deref,
    "!" => UnOpKind::Not,
    "-" => UnOpKind::Neg,
}

UnOp: UnOp = {
    <un:(@L UnOpKind @R)> => UnOp {
        kind: un.1,
        span: Span::new(un.0, un.2),
    }
}

ExprAtomic: P<Expr> = {
    #[precedence(level = "0")]
    <ident:Ident> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Ident(ident),
        span: ident.span,
        attrs: vec![],
    }),

    <lit:(@L "literal" @R)> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Literal(lit.1),
        span: Span::new(lit.0, lit.2),
        attrs: vec![],
    }),

    #[precedence(level = "1")] #[assoc(side = "left")]
    <e:ExprAtomic> <op:(@L "." @R)> <func:ExprAtomic> => {
        let span = Span::new(e.span.start, func.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::InfixCall(e, Span::new(op.0, op.2), func),
            span,
            attrs: vec![],
        })
    }
}

Delimited: P<Expr> = {
    <delim:"delim"> =>? parse_delim(cx, delim),
}

ExprUnary: P<Expr> = {
    #[precedence(level = "0")]
    ExprAtomic,

    <lo:@L> <un:UnOp> <e:ExprAtomic> <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Unary(un, e),
            span: Span::new(lo, hi),
            attrs: vec![],
        })
    },

    <lo:@L> "&" <l:Lifetime?> <m:Mutability> <e:ExprUnary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::AddrOf(l, m, e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    #[precedence(level = "1")] #[assoc(side = "left")]
    <func:ExprUnary> <arg:ExprAtomic> => {
        let span = Span::new(func.span.start, arg.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Call(func, arg),
            span,
            attrs: vec![],
        })
    },
}

ExprBinary: P<Expr> = {
    #[precedence(level = "0")]
    ExprUnary,

    #[precedence(level = "1")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "*"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Mul, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "/"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Div, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "%"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Rem, op.2), rhs),

    #[precedence(level = "2")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "+"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Add, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "-"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Sub, op.2), rhs),

    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "<<"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Shl, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">>"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Shr, op.2), rhs),

    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "^"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::BitXor, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "&"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::BitAnd, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "|"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::BitOr, op.2), rhs),

    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "=="  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Eq, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "!="  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Ne, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Lt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Gt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<="  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Le, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">="  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Ge, op.2), rhs),

    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "&&"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::And, op.2), rhs),

    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "||"  @R)> <rhs:(ExprBinary @R)> => 
        expr::parse_bin(lhs, (op.0, BinOpKind::Or, op.2), rhs),
}

pub Expr: P<Expr> = {
    ExprBinary,

    <lo:@L> "try" <e:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Try(e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    <lo:@L> "exists" <e:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Exists(e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),
}

__unused: PhantomData<&'a DiagCx> = {
    <Ident> => PhantomData,
}
