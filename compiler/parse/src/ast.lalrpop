use std::marker::PhantomData;

use dendro_ast::{ast::*, token, token_stream::*};
use dendro_span::{span::*, symbol::*, ident::*};

use crate::imp::*;

grammar<'diag, 'a>(
    diag: &'diag DiagCx,
    cx: &'a mut ParseCx,
);

extern {
    type Location = Pos;
    type Error = dendro_error::DiagnosticBuilder<'diag>;

    enum SpacedToken<'diag> {
        "(" => (_, T(token::OpenDelim(token::Parenthesis)), _),
        ")" => (_, T(token::CloseDelim(token::Parenthesis)), _),
        "`[" => (Spacing::Joint, T(token::OpenDelim(token::Bracket)), _),
        "[" => (_, T(token::OpenDelim(token::Bracket)), _),
        "]" => (_, T(token::CloseDelim(token::Bracket)), _),
        "{" => (_, T(token::OpenDelim(token::Brace)), _),
        "}" => (_, T(token::CloseDelim(token::Brace)), _),

        "=" => (_, T(token::Eq), _),
        "<" => (_, T(token::Lt), _),
        "<=" => (_, T(token::Le), _),
        "==" => (_, T(token::EqEq), _),
        "!=" => (_, T(token::Ne), _),
        ">=" => (_, T(token::Ge), _),
        ">" => (_, T(token::Gt), _),
        "&&" => (_, T(token::AndAnd), _),
        "||" => (_, T(token::OrOr), _),
        "++" => (_, T(token::PlusPlus), _),
        "!" => (_, T(token::Not), _),
        "~" => (_, T(token::Tilde), _),
        "`" => (_, T(token::BackQuote), _),
        "\\`" => (_, T(token::BackSlash), Spacing::Joint),
        "\\" => (_, T(token::BackSlash), _),

        "-`" => (_, T(token::BinOp(token::Minus)), Spacing::Joint),
        "*`" => (_, T(token::BinOp(token::Star)), Spacing::Joint),
        "&`" => (_, T(token::BinOp(token::And)), Spacing::Joint),

        "+" => (_, T(token::BinOp(token::Plus)), _),
        "-" => (_, T(token::BinOp(token::Minus)), _),
        "*" => (_, T(token::BinOp(token::Star)), _),
        "/" => (_, T(token::BinOp(token::Slash)), _),
        "%" => (_, T(token::BinOp(token::Percent)), _),
        "^" => (_, T(token::BinOp(token::Caret)), _),
        "&" => (_, T(token::BinOp(token::And)), _),
        "|" => (_, T(token::BinOp(token::Or)), _),
        "<<" => (_, T(token::BinOp(token::Shl)), _),
        ">>" => (_, T(token::BinOp(token::Shr)), _),

        "+=" => (_, T(token::BinOpEq(token::Plus)), _),
        "-=" => (_, T(token::BinOpEq(token::Minus)), _),
        "*=" => (_, T(token::BinOpEq(token::Star)), _),
        "/=" => (_, T(token::BinOpEq(token::Slash)), _),
        "%=" => (_, T(token::BinOpEq(token::Percent)), _),
        "^=" => (_, T(token::BinOpEq(token::Caret)), _),
        "&=" => (_, T(token::BinOpEq(token::And)), _),
        "|=" => (_, T(token::BinOpEq(token::Or)), _),
        "<<=" => (_, T(token::BinOpEq(token::Shl)), _),
        ">>=" => (_, T(token::BinOpEq(token::Shr)), _),

        "@" => (_, T(token::At), _),
        "." => (Spacing::Alone, T(token::Dot), _),
        "`." => (Spacing::Joint, T(token::Dot), _),
        ".." => (Spacing::Alone, T(token::DotDot), Spacing::Alone),
        "`.." => (Spacing::Joint, T(token::DotDot), Spacing::Alone),
        "..`" => (Spacing::Alone, T(token::DotDot), Spacing::Joint),
        "`..`" => (Spacing::Joint, T(token::DotDot), Spacing::Joint),
        "..." => (_, T(token::DotDotDot), _),
        "..=" => (Spacing::Alone, T(token::DotDotEq), Spacing::Alone),
        "`..=" => (Spacing::Joint, T(token::DotDotEq), Spacing::Alone),
        "..=`" => (Spacing::Alone, T(token::DotDotEq), Spacing::Joint),
        "`..=`" => (Spacing::Joint, T(token::DotDotEq), Spacing::Joint),
        "," => (_, T(token::Comma), _),
        ";" => (_, T(token::Semi), _),
        ":" => (_, T(token::Colon), _),
        "::" => (Spacing::Alone, T(token::ColonColon), Spacing::Alone),
        "`::`" => (Spacing::Joint, T(token::ColonColon), Spacing::Joint),
        ":=" => (_, T(token::ColonEq), _),
        "->" => (_, T(token::RArrow), _),
        "<-" => (_, T(token::LArrow), _),
        "=>" => (_, T(token::FatArrow), _),
        "#" => (_, T(token::Pound), _),
        "$" => (_, T(token::Dollar), _),
        "?" => (_, T(token::Question), _),
        "'" => (_, T(token::SingleQuote), _),

        "_" => (_, T(token::Ident(kw::UNDERSCORE, false)), _),
        "KW:forall" => (_, T(token::Ident(kw::FORALL, false)), _),
        "KW:exists" => (_, T(token::Ident(kw::EXISTS, false)), _),
        "KW:where" => (_, T(token::Ident(kw::WHERE, false)), _),
        "KW:let" => (_, T(token::Ident(kw::LET, false)), _),
        "KW:pub" => (_, T(token::Ident(kw::PUB, false)), _),
        "KW:static" => (_, T(token::Ident(kw::STATIC, false)), _),
        "KW:unsafe" => (_, T(token::Ident(kw::UNSAFE, false)), _),
        "KW:default" => (_, T(token::Ident(kw::DEFAULT, false)), _),
        "KW:const" => (_, T(token::Ident(kw::CONST, false)), _),
        "KW:mut" => (_, T(token::Ident(kw::MUT, false)), _),
        "KW:move" => (_, T(token::Ident(kw::MOVE, false)), _),
        "KW:return" => (_, T(token::Ident(kw::RETURN, false)), _),
        "KW:in" => (_, T(token::Ident(kw::IN, false)), _),
        "KW:if" => (_, T(token::Ident(kw::IF, false)), _),
        "KW:else" => (_, T(token::Ident(kw::ELSE, false)), _),
        "KW:loop" => (_, T(token::Ident(kw::LOOP, false)), _),
        "KW:while" => (_, T(token::Ident(kw::WHILE, false)), _),
        "KW:break" => (_, T(token::Ident(kw::BREAK, false)), _),
        "KW:continue" => (_, T(token::Ident(kw::CONTINUE, false)), _),
        "KW:for" => (_, T(token::Ident(kw::FOR, false)), _),
        "KW:match" => (_, T(token::Ident(kw::MATCH, false)), _),
        "KW:leaf" => (_, T(token::Ident(kw::LEAF, false)), _),
        "KW:try" => (_, T(token::Ident(kw::TRY, false)), _),
        "KW:ref" => (_, T(token::Ident(kw::REF, false)), _),
        "KW:then" => (_, T(token::Ident(kw::THEN, false)), _),
        "KW:do" => (_, T(token::Ident(kw::DO, false)), _),
        "KW:with" => (_, T(token::Ident(kw::WITH, false)), _),
        "KW:super" => (_, T(token::Ident(kw::SUPER, false)), _),
        "KW:self" => (_, T(token::Ident(kw::SELF, false)), _),

        "literal" => (_, T(token::Literal(<token::Lit>)), _),
        "ident" => (_, T(token::Ident(<Symbol>, <bool>)), _),
        "lifetime" => (_, T(token::Lifetime(<Symbol>)), _),
        "inner attr" => (_, InnerAttr(<PResult<'diag, Attribute>>), _),
        "outer attr" => (_, OuterAttr(<PResult<'diag, Attribute>>), _),
        "inner doc" => (
            _,
            T(token::DocComment(<token::CommentKind>, AttrStyle::Inner, <Symbol>)),
            _,
        ),
        "outer doc" => (
            _,
            T(token::DocComment(<token::CommentKind>, AttrStyle::Outer, <Symbol>)),
            _,
        ),
    }
}

// ------------------------------------------
// Units

#[inline]
Visibility: VisibilityKind = {
    "KW:pub" "(" "KW:in" <e:ExprPath> ")" => VisibilityKind::Restricted {
        path: e,
        id: DUMMY_ID,
    },
    "KW:pub" => VisibilityKind::Public,
}

OuterAttr: Attribute = {
    <"outer attr"> =>? Ok(<>?),
    <lo:@L> <doc:"outer doc"> <hi:@R> => Attribute {
        id: DUMMY_ID,
        style: AttrStyle::Outer,
        kind: AttrKind::Comment(doc.0, doc.1),
        span: Span::new(lo, hi),
    }
}

InnerAttr: () = {
    <"inner attr"> =>? Ok(cx.push_attr(<>?)),
    <lo:@L> <doc:"inner doc"> <hi:@R> => cx.push_attr(Attribute {
        id: DUMMY_ID,
        style: AttrStyle::Inner,
        kind: AttrKind::Comment(doc.0, doc.1),
        span: Span::new(lo, hi),
    }),
}

RangeLimits: RangeLimits = {
    ".." => RangeLimits::HalfOpen,
    "..=" => RangeLimits::Closed,
}

#[inline]
Range<T>: (Option<T>, RangeLimits, Option<T>, Span) = {
}

#[inline]
RangeTo<T>: (RangeLimits, T, Span) = {
    <lo:@L> "..`" <rhs:T> <hi:@R> => {
        (RangeLimits::HalfOpen, rhs, Span::new(lo, hi))
    },
    <lo:@L> "..=`" <rhs:T> <hi:@R> => {
        (RangeLimits::Closed, rhs, Span::new(lo, hi))
    },
}

#[inline]
Attrs: Vec<Attribute> = OuterAttr*;

#[inline]
AssignOp: BinOp = {
    <lo:@L> "+=" <hi:@R> => BinOp::new(BinOpKind::Add, Span::new(lo, hi)),
    <lo:@L> "-=" <hi:@R> => BinOp::new(BinOpKind::Sub, Span::new(lo, hi)),
    <lo:@L> "*=" <hi:@R> => BinOp::new(BinOpKind::Mul, Span::new(lo, hi)),
    <lo:@L> "/=" <hi:@R> => BinOp::new(BinOpKind::Div, Span::new(lo, hi)),
    <lo:@L> "%=" <hi:@R> => BinOp::new(BinOpKind::Rem, Span::new(lo, hi)),
    <lo:@L> "^=" <hi:@R> => BinOp::new(BinOpKind::BitXor, Span::new(lo, hi)),
    <lo:@L> "&=" <hi:@R> => BinOp::new(BinOpKind::BitAnd, Span::new(lo, hi)),
    <lo:@L> "|=" <hi:@R> => BinOp::new(BinOpKind::BitOr, Span::new(lo, hi)),
    <lo:@L> "<<=" <hi:@R> => BinOp::new(BinOpKind::Shl, Span::new(lo, hi)),
    <lo:@L> ">>=" <hi:@R> => BinOp::new(BinOpKind::Shr, Span::new(lo, hi)),
}

#[inline]
Operator: Operator = {
    AssignOp => Operator::AssignBinary(<>),

    <lo:@L> "=" <hi:@R> => Operator::from_assign(Span::new(lo, hi)),
    <lo:@L> "<" <hi:@R> => Operator::from_bin(BinOpKind::Lt, Span::new(lo, hi)),
    <lo:@L> "<=" <hi:@R> => Operator::from_bin(BinOpKind::Le, Span::new(lo, hi)),
    <lo:@L> "==" <hi:@R> => Operator::from_bin(BinOpKind::Eq, Span::new(lo, hi)),
    <lo:@L> "!=" <hi:@R> => Operator::from_bin(BinOpKind::Ne, Span::new(lo, hi)),
    <lo:@L> ">=" <hi:@R> => Operator::from_bin(BinOpKind::Ge, Span::new(lo, hi)),
    <lo:@L> ">" <hi:@R> => Operator::from_bin(BinOpKind::Gt, Span::new(lo, hi)),
    <lo:@L> "&&" <hi:@R> => Operator::from_bin(BinOpKind::And, Span::new(lo, hi)),
    <lo:@L> "||" <hi:@R> => Operator::from_bin(BinOpKind::Or, Span::new(lo, hi)),

    <lo:@L> "!" <hi:@R> => Operator::from_un(UnOpKind::Not, Span::new(lo, hi)),
    <lo:@L> "`" "-" <hi:@R> => Operator::from_un(UnOpKind::Neg, Span::new(lo, hi)),
    <lo:@L> "`" "*" <hi:@R> => Operator::from_un(UnOpKind::Deref, Span::new(lo, hi)),

    <lo:@L> "+" <hi:@R> => Operator::from_bin(BinOpKind::Add, Span::new(lo, hi)),
    <lo:@L> "-" <hi:@R> => Operator::from_bin(BinOpKind::Sub, Span::new(lo, hi)),
    <lo:@L> "*" <hi:@R> => Operator::from_bin(BinOpKind::Mul, Span::new(lo, hi)),
    <lo:@L> "/" <hi:@R> => Operator::from_bin(BinOpKind::Div, Span::new(lo, hi)),
    <lo:@L> "%" <hi:@R> => Operator::from_bin(BinOpKind::Rem, Span::new(lo, hi)),
    <lo:@L> "^" <hi:@R> => Operator::from_bin(BinOpKind::BitXor, Span::new(lo, hi)),
    <lo:@L> "&" <hi:@R> => Operator::from_bin(BinOpKind::BitAnd, Span::new(lo, hi)),
    <lo:@L> "|" <hi:@R> => Operator::from_bin(BinOpKind::BitOr, Span::new(lo, hi)),
    <lo:@L> "<<" <hi:@R> => Operator::from_bin(BinOpKind::Shl, Span::new(lo, hi)),
    <lo:@L> ">>" <hi:@R> => Operator::from_bin(BinOpKind::Shr, Span::new(lo, hi)),

    <lo:@L> "[" "`" "]" <hi:@R> => Operator::Index(Span::new(lo, hi)),
}

// ------------------------------------------
// Identifiers

Ident: Ident = {
    <lo:@L> <ident:"ident"> <hi:@R> =>? 
        ident::parse_ident(diag, Span::new(lo, hi), ident),
}

Lifetime: Lifetime = {
    <lo:@L> <lifetime:"lifetime"> <hi:@R> => Lifetime {
        id: DUMMY_ID,
        ident: Ident::new(lifetime, Span::new(lo, hi)),
    },
}

#[inline]
Mutability: Mutability = {
    "KW:const"? => Mutability::kw(kw::CONST),
    "KW:mut" => Mutability::kw(kw::MUT),
    "KW:move" => Mutability::kw(kw::MOVE),
    "#" <ident:Ident> => Mutability { id: DUMMY_ID, ident },
}

PathRoot: PathRoot = {
    "KW:self" => PathRoot::This,
    "KW:super" => PathRoot::Super,
    "KW:leaf" => PathRoot::Leaf,
}

// ------------------------------------------
// Expressions

Where: Vec<P<Expr>> = {
    "KW:where" <first:Expr> <next:("," Expr)*> ","? => {
        [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect()
    },
}

Prerequisites: Prerequisites = {
    <lo:@L>
        "KW:forall" <first:Ident> <next:("," Ident)*>
        <w:Where?> "::"
    <hi:@R> => {
        Prerequisites {
            id: DUMMY_ID,
            forall: [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect(),
            where_clause: w.unwrap_or_default(),
            span: Span::new(lo, hi),
        }
    },
}

UnOpKind: UnOpKind = {
    "*`" => UnOpKind::Deref,
    "!" => UnOpKind::Not,
    "-`" => UnOpKind::Neg,
}

UnOp: UnOp = {
    <un:(@L UnOpKind @R)> => UnOp {
        kind: un.1,
        span: Span::new(un.0, un.2),
    },
}

ExprTuple: P<Expr> = {
    <lo:@L> "(" ")" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Tuple(vec![]),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
    <lo:@L> "(" <e:Expr> "," ")" <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Tuple(vec![e]),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },
    <lo:@L> "("
        <first:Expr>
        <next:("," Expr)+>
        ","?
    ")" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Tuple(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

ExprArray: P<Expr> = {
    <lo:@L> "[" "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Array(vec![]),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "[" <first:Expr> <next:("," Expr)*> ","? "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Array(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "[" <e:Expr> ";" <count:Expr> "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::ArrayRepeated(e, count),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

StructField: StructField = {
    <lo:@L>
        <prereq:(Prerequisites? @R)>
        <attrs:Attrs>
        <vlo:@L> <vis:Visibility?> <vhi:@R>
        <pat:PatAtomic> ":" <e:Expr>
    <hi:@R> => StructField {
        id: DUMMY_ID,
        prerequisites: prereq.0.unwrap_or_else(|| {
            Prerequisites::from_span(Span::new(lo, prereq.1))
        }),
        attrs: cx.take_attr(attrs),
        visibility: vis.map_or(
            Visibility {
                kind: VisibilityKind::Inherited,
                span: Span::new(vlo, vhi),
            },
            |v| parse_vis((vlo, v, vhi)),
        ),
        pat,
        expr: e,
        span: Span::new(lo, hi),
    },
}

#[inline]
StructRest: StructRest = {
    "..`" <e:Expr> => StructRest::Base(e),
    ".." => StructRest::Rest,
}

ExprStruct: P<Expr> = {
    <lo:@L> "\\`" "{" <rest:StructRest?> "}" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Struct(vec![], rest.unwrap_or_default()),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L>  "\\`" "{"
        <first:StructField>
        <next:("," StructField)*> ","?
    "}" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Struct(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|(_, f)| f))
                .collect(),
            StructRest::None,
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L>  "\\`" "{"
        <first:StructField>
        <next:("," StructField)*> "," <rest:StructRest>
    "}" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Struct(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|(_, f)| f))
                .collect(),
            rest,
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

ExprUnloadedBlock: P<Expr> = {
    <lo:@L> "`" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Block(P(Block {
            id: DUMMY_ID,
            kind: BlockKind::Unloaded,
            is_unsafe: false,
        })),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

ExprBlock: P<Block> = {
    <is_unsafe:"KW:unsafe"?> "{" <lo:@L>
        InnerAttr*
        <mut stmts:Stmt*>
        <last:StmtSemi?>
    <hi:@R> "}" => P(Block {
        id: DUMMY_ID,
        kind: BlockKind::Loaded {
            stmts: {
                stmts.extend(last);
                stmts
            },
            is_inline: false,
            span: Span::new(lo, hi),
        },
        is_unsafe: is_unsafe.is_some(),
    }),
}

ExprAtomic: P<Expr> = {
    <lo:@L> "(" <op:Operator> ")" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Operator(op),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    "(" <e:Expr> ")" => e,

    <lo:@L> <block:ExprBlock> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Block(block),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "_" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Underscore,
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
    
    <lo:@L> ".." <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(None, RangeLimits::HalfOpen, None),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <ident:Ident> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Ident(ident),
        span: ident.span,
        attrs: cx.take_attr(vec![]),
    }),

    <lit:(@L "literal" @R)> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Literal(lit.1),
        span: Span::new(lit.0, lit.2),
        attrs: cx.take_attr(vec![]),
    }),
}

pub ExprPath: P<Expr> = {
    ExprAtomic,

    <lo:@L>
        <root:PathRoot> "`::`"
        <e:(ExprAtomic "`::`")*>
        <last:ExprAtomic>
    <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Path(
            root,
            e.into_iter().map(|e| e.0).chain([last]).collect(),
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> <root:PathRoot> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Path(root, vec![]),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

#[inline]
ExprNonArray: P<Expr> = {
    ExprPath,
    ExprTuple,
    ExprStruct,
}

ExprDelimited: P<Expr> = {
    #[precedence(level = "0")]
    ExprNonArray,
    ExprArray,

    <lo:@L> <e:ExprDelimited> "`[" <index:Expr> "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Index(e, index),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    #[precedence(level = "1")] #[assoc(side = "left")]
    <e:ExprDelimited> <op:(@L "`." @R)> <func:ExprPath> => {
        let span = Span::new(e.span.start, func.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::InfixCall(e, Span::new(op.0, op.2), func),
            span,
            attrs: cx.take_attr(vec![]),
        })
    },
}

ExprUnary: P<Expr> = {
    ExprDelimited,

    <lo:@L> <un:UnOp> <e:ExprUnary> <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Unary(un, e),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },

    <lo:@L> "&`" <l:Lifetime?> <m:Mutability> <e:ExprUnary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::AddrOf(l, m, e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

ExprBinary: P<Expr> = {
    #[precedence(level = "0")]
    ExprUnary,

    #[precedence(level = "1")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "*"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Mul, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "/"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Div, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "%"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Rem, op.2), rhs),

    #[precedence(level = "2")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "+"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Add, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "-"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Sub, op.2), rhs),

    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "<<"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Shl, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">>"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Shr, op.2), rhs),

    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "^"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitXor, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "&"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitAnd, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "|"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitOr, op.2), rhs),

    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "=="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Eq, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "!="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Ne, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Lt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Gt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Le, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Ge, op.2), rhs),

    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "&&"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::And, op.2), rhs),

    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "||"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Or, op.2), rhs),

    #[precedence(level = "8")] #[assoc(side = "left")]
    <lo:@L> <lhs:ExprBinary> "`..=`" <rhs:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(Some(lhs), RangeLimits::Closed, Some(rhs)),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
    <lo:@L> <lhs:ExprBinary> "`..`" <rhs:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(Some(lhs), RangeLimits::HalfOpen, Some(rhs)),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
    <lo:@L> <lhs:ExprBinary> "`.." <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(Some(lhs), RangeLimits::HalfOpen, None),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    #[precedence(level = "9")]
    <r:RangeTo<ExprBinary>> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(None, r.0, Some(r.1)),
        span: r.2,
        attrs: cx.take_attr(vec![]),
    })
}

MatchArm: MatchArm = {
    <lo:@L> <prereq:Prerequisites?> <hi:@R>
    <attrs:Attrs>
    <pat:Pat> <guard:("KW:if" Expr)?> "=>" <expr:Expr> => MatchArm {
        prerequisites: prereq.unwrap_or_else(|| {
            Prerequisites::from_span(Span::new(lo, hi))
        }),
        attrs: cx.take_attr(attrs),
        pat,
        guard: guard.map(|(_, expr)| expr),
        expr,
    }
}

#[inline]
LetExpr: P<Expr> = {
    Expr,
    ExprUnloadedBlock,
}

ExprUnannotated: P<Expr> = {
    #[precedence(level = "0")]
    ExprBinary,

    <lo:@L> "\\" <arg:PatOp> <ty:(":" Expr)?> "->" <body:(ExprBinary @R)> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Lambda(arg, ty.map(|ty| ty.1), body.0),
        span: Span::new(lo, body.1),
        attrs: cx.take_attr(vec![]),
    }),

    #[precedence(level = "1")] #[assoc(side = "left")]

    <func:ExprUnannotated> <arg:ExprUnannotated> => {
        let span = Span::new(func.span.start, arg.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Call(func, arg),
            span,
            attrs: cx.take_attr(vec![]),
        })
    },

    <e:ExprUnannotated> <op:(@L "." @R)> <func:ExprPath> => {
        let span = Span::new(e.span.start, func.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::InfixCall(e, Span::new(op.0, op.2), func),
            span,
            attrs: cx.take_attr(vec![]),
        })
    },

    #[precedence(level = "2")] #[assoc(side = "left")]
    <mut lhs:ExprUnannotated> "++" <rhs:ExprUnannotated> => match &mut lhs.kind {
        ExprKind::Enum(e) => {
            let end = rhs.span.end;
            e.push(rhs);
            lhs.span.end = end;
            lhs
        }
        _ => P(Expr {
            id: DUMMY_ID,
            span: Span::new(lhs.span.start, rhs.span.end),
            kind: ExprKind::Enum(vec![lhs, rhs]),
            attrs: cx.take_attr(vec![]),
        })
    },

    #[precedence(level = "3")] #[assoc(side = "right")]

    <lo:@L> <lhs:ExprDelimited> <op:(@L "=" @R)> <rhs:Expr> <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Assign(lhs, Span::new(op.0, op.2), rhs),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },

    <lo:@L> <lhs:ExprDelimited> <op:AssignOp> <rhs:Expr> <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::AssignOp(lhs, op, rhs),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },

    <lo:@L> <lhs:ExprDelimited> ":" <rhs:Expr> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::BelongsTo(lhs, rhs),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    #[precedence(level = "4")]

    <lo:@L>
        <is_unsafe:"KW:unsafe"?> "KW:let" <pat:PatOp>
        <ty:(":" Expr)?>
        ":=" <expr:LetExpr>
    <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Let(Let {
            is_unsafe: is_unsafe.is_some(),
            pat,
            ty: ty.map(|(_, ty)| ty),
            expr,
        }),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:if" <pred:Expr>
        "KW:then" <e:ExprUnannotated>
        "KW:else" <other:ExprUnannotated>
    <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::If(pred, e, Some(other)),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },

    <lo:@L> "KW:while" <pred:Expr> "KW:do" <body:ExprUnannotated> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::While(pred, body),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:loop" <body:ExprUnannotated> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Loop(body),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:for" <pat:Pat> "KW:in" <e:Expr>
        "KW:do" <body:ExprUnannotated>
    <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::ForLoop(pat, e, body),
            span: Span::new(lo, hi),
            attrs: cx.take_attr(vec![]),
        })
    },

    <lo:@L> "KW:match" <pred:Expr> "KW:with" "{" "}" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Match(pred, vec![]),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:match" <pred:Expr> "KW:with" "{"
        <first:MatchArm> <next:("," MatchArm)*> ","?
    "}" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Match(
            pred,
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:exists" <e:ExprUnannotated> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Exists(e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:break" <l:Lifetime?> <e:ExprUnannotated?> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Break(l, e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:continue" <l:Lifetime?> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Continue(l),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> "KW:return" <e:ExprUnannotated?> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Return(e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),
}

pub Expr: P<Expr> = {
    ExprUnannotated,

    <lo:@L> <l:Lifetime> ":" <e:Expr> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Annotated(l, e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L> <prereq:Prerequisites> <e:Expr> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Prereq(prereq, e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <lo:@L>
        <vis:(@L Visibility @R)>
        <e:ExprUnannotated>
    <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Vis(parse_vis(vis), e),
        span: Span::new(lo, hi),
        attrs: cx.take_attr(vec![]),
    }),

    <attr:OuterAttr> <mut e:Expr> => {
        e.attrs.push(attr);
        e
    },
}

// ------------------------------------------
// Patterns

#[inline]
BindingMode: BindingMode = {
    "KW:ref"? => match <> {
        Some(_) => BindingMode::ByRef,
        None => BindingMode::ByValue,
    }
}

PatTuple: P<Pat> = {
    <lo:@L> "(" ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(vec![]),
        span: Span::new(lo, hi),
    }),
    <lo:@L> "(" <e:PatOp> "," ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(vec![e]),
        span: Span::new(lo, hi),
    }),
    <lo:@L> "(" <first:PatOp> <next:("," PatOp)+> ","? ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
    }),
}

PatArray: P<Pat> = {
    <lo:@L> "[" "]" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Array(vec![]),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "[" <first:PatOp> <next:("," PatOp)*> ","? "]" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Array(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
    }),
}

PatField: PatField = {
    <lo:@L>
        <mode:BindingMode> <m:Mutability> <ident:Ident>
    <hi:@R> => PatField {
        id: DUMMY_ID,
        ident,
        pat: pat::parse_ident(Span::new(lo, hi), mode, m, ident),
        span: Span::new(lo, hi),
        is_shorthand: false,
        is_placeholder: false,
    },

    <lo:@L> <ident:Ident> ":" <pat:PatOp> <hi:@R> => PatField {
        id: DUMMY_ID,
        ident,
        pat,
        span: Span::new(lo, hi),
        is_shorthand: true,
        is_placeholder: false,
    },
}

PatStruct: P<Pat> = {
    <lo:@L> "\\`" "{" <recover:".."?> "}" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Struct(vec![], recover.is_some()),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "\\`" "{"
        <first:PatField>
        <fields:("," PatField)*> ","?
    "}" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Struct(
            vec![first]
                .into_iter()
                .chain(fields.into_iter().map(|n| n.1))
                .collect(),
            false,
        ),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "\\`" "{"
        <first:PatField>
        <fields:("," PatField)*> "," ".."
    "}" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Struct(
            vec![first]
                .into_iter()
                .chain(fields.into_iter().map(|n| n.1))
                .collect(),
            true,
        ),
        span: Span::new(lo, hi),
    }),
}

PatAtomic: P<Pat> = {
    <lo:@L> "(" <pat:Pat> ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Paren(pat),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "_" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Wildcard,
        span: Span::new(lo, hi)
    }),
    
    <lo:@L> ".." <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(None, RangeLimits::HalfOpen, None),
        span: Span::new(lo, hi),
    }),

    <lo:@L> <lit:"literal"> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Literal(lit),
        span: Span::new(lo, hi),
    }),

    PatArray,
    PatTuple,
    PatStruct,
}

PatPath: P<Pat> = {
    <lo:@L>
        <root:PathRoot> "`::`"
        <e:(PatAtomic "`::`")*>
        <last:PatAtomic>
    <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Path(
            root,
            e.into_iter().map(|e| e.0).chain([last]).collect(),
        ),
        span: Span::new(lo, hi),
    }),

    <lo:@L> <root:PathRoot> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Path(root, vec![]),
        span: Span::new(lo, hi),
    }),
}

PatOp: P<Pat> = {
    #[precedence(level = "0")]
    PatAtomic,

    PatPath,

    #[precedence(level = "1")] #[assoc(side = "left")]
    <lo:@L> <lhs:PatOp> "`..=`" <rhs:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(Some(lhs), RangeLimits::Closed, Some(rhs)),
        span: Span::new(lo, hi),
    }),
    <lo:@L> <lhs:PatOp> "`..`" <rhs:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(Some(lhs), RangeLimits::HalfOpen, Some(rhs)),
        span: Span::new(lo, hi),
    }),
    <lo:@L> <lhs:PatOp> "`.." <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(Some(lhs), RangeLimits::HalfOpen, None),
        span: Span::new(lo, hi),
    }),

    #[precedence(level = "2")]
    <r:RangeTo<PatOp>> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(None, r.0, Some(r.1)),
        span: r.2,
    }),

    #[precedence(level = "3")]
    <lo:@L> "&`" <l:Lifetime?> <m:Mutability> <i:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Deref(l, m, i),
        span: Span::new(lo, hi),
    }),

    #[precedence(level = "4")]
    <lo:@L>
        <i_lo:@L> <mode:BindingMode> <m:Mutability> <ident:Ident> <i_hi:@R>
        <alias:("@" PatOp)?>
    <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Ident(mode, m, ident, alias.map(|p| p.1)),
        span: Span::new(lo, hi)
    }),

    #[precedence(level = "5")] #[assoc(side = "left")]
    <lo:@L> <func:PatOp> <arg:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Call(func, arg),
        span: Span::new(lo, hi),
    }),
}

Pat: P<Pat> = {
    PatOp,

    <lo:@L> <lhs:(PatOp "|")+> <rhs:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Or(lhs.into_iter().map(|p| p.0).chain([rhs]).collect()),
        span: Span::new(lo, hi),
    }),
}

// ------------------------------------------
// Statements

Stmt: P<Stmt> = {
    <lo:@L> <e:Expr> ";" <hi:@R> => P(Stmt {
        id: DUMMY_ID,
        kind: StmtKind::Expr(e),
        span: Span::new(lo, hi),
    }),

    <lo:@L> ";" <hi:@R> => P(Stmt {
        id: DUMMY_ID,
        kind: StmtKind::Empty,
        span: Span::new(lo, hi),
    }),
}

StmtSemi: P<Stmt> = {
    <e:Expr> => {
        let span = e.span;
        P(Stmt {
            id: DUMMY_ID,
            kind: StmtKind::Semi(e),
            span,
        })
    },
}

pub Stmts: Vec<P<Stmt>> = {
    <stmts:Stmt*> <fin:StmtSemi?> =>
        stmts.into_iter().chain(fin).collect(),
}
