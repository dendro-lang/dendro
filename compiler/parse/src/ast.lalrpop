use std::marker::PhantomData;

use dendro_ast::{ast::*, token::{self, TokenKind}, token_stream::*};
use dendro_span::{span::*, symbol::*, ident::*};

use crate::imp::*;

grammar<'diag, 'a, 'cx>(
    diag: &'diag DiagCx,
    cx: &'a mut ParseCx<'cx>,
);

extern {
    type Location = Pos;
    type Error = dendro_error::DiagnosticBuilder<'diag>;

    enum TokenKind {
        "(" => token::OpenDelim(token::Parenthesis),
        ")" => token::CloseDelim(token::Parenthesis),
        "[" => token::OpenDelim(token::Bracket),
        "]" => token::CloseDelim(token::Bracket),
        "{" => token::OpenDelim(token::Brace),
        "}" => token::CloseDelim(token::Brace),
        "open delim" => token::OpenDelim(<token::Delimiter>),
        "close delim" => token::CloseDelim(<token::Delimiter>),

        "=" => token::Eq,
        "<" => token::Lt,
        "<=" => token::Le,
        "==" => token::EqEq,
        "!=" => token::Ne,
        ">=" => token::Ge,
        ">" => token::Gt,
        "&&" => token::AndAnd,
        "||" => token::OrOr,
        "!" => token::Not,
        "~" => token::Tilde,
        "`" => token::BackQuote,
        "\\" => token::BackSlash,

        "+" => token::BinOp(token::Plus),
        "-" => token::BinOp(token::Minus),
        "*" => token::BinOp(token::Star),
        "/" => token::BinOp(token::Slash),
        "%" => token::BinOp(token::Percent),
        "^" => token::BinOp(token::Caret),
        "&" => token::BinOp(token::And),
        "|" => token::BinOp(token::Or),
        "<<" => token::BinOp(token::Shl),
        ">>" => token::BinOp(token::Shr),

        "+=" => token::BinOpEq(token::Plus),
        "-=" => token::BinOpEq(token::Minus),
        "*=" => token::BinOpEq(token::Star),
        "/=" => token::BinOpEq(token::Slash),
        "%=" => token::BinOpEq(token::Percent),
        "^=" => token::BinOpEq(token::Caret),
        "&=" => token::BinOpEq(token::And),
        "|=" => token::BinOpEq(token::Or),
        "<<=" => token::BinOpEq(token::Shl),
        ">>=" => token::BinOpEq(token::Shr),

        "@" => token::At,
        "." => token::Dot,
        ".." => token::DotDot,
        "..." => token::DotDotDot,
        "..=" => token::DotDotEq,
        "," => token::Comma,
        ";" => token::Semi,
        ":" => token::Colon,
        "::" => token::ColonColon,
        "->" => token::RArrow,
        "<-" => token::LArrow,
        "=>" => token::FatArrow,
        "#" => token::Pound,
        "$" => token::Dollar,
        "?" => token::Question,
        "'" => token::SingleQuote,

        "_" => token::Ident(kw::UNDERSCORE, false),
        "forall" => token::Ident(kw::FORALL, false),
        "exists" => token::Ident(kw::EXISTS, false),
        "where" => token::Ident(kw::WHERE, false),
        "let" => token::Ident(kw::LET, false),
        "pub" => token::Ident(kw::PUB, false),
        "static" => token::Ident(kw::STATIC, false),
        "unsafe" => token::Ident(kw::UNSAFE, false),
        "default" => token::Ident(kw::DEFAULT, false),
        "const" => token::Ident(kw::CONST, false),
        "mut" => token::Ident(kw::MUT, false),
        "move" => token::Ident(kw::MOVE, false),
        "return" => token::Ident(kw::RETURN, false),
        "in" => token::Ident(kw::IN, false),
        "if" => token::Ident(kw::IF, false),
        "else" => token::Ident(kw::ELSE, false),
        "loop" => token::Ident(kw::LOOP, false),
        "while" => token::Ident(kw::WHILE, false),
        "break" => token::Ident(kw::BREAK, false),
        "continue" => token::Ident(kw::CONTINUE, false),
        "for" => token::Ident(kw::FOR, false),
        "match" => token::Ident(kw::MATCH, false),
        "leaf" => token::Ident(kw::LEAF, false),
        "try" => token::Ident(kw::TRY, false),
        "ref" => token::Ident(kw::REF, false),

        "literal" => token::Literal(<token::Lit>),
        "ident" => token::Ident(<Symbol>, <bool>),
        "lifetime" => token::Lifetime(<Symbol>),
        "inner doc" => token::DocComment(<token::CommentKind>, AttrStyle::Inner, <Symbol>),
        "outer doc" => token::DocComment(<token::CommentKind>, AttrStyle::Outer, <Symbol>),
    }
}

#[inline]
Visibility: VisibilityKind = {
    "pub" "(" "in" <e:ExprPath> ")" => VisibilityKind::Restricted {
        path: e,
        id: DUMMY_ID,
    },
    "pub" => VisibilityKind::Public,
}

AttrArgsOpt: AttrArgs = {
    <eq:(@L "=" @R)> <e:Expr> => AttrArgs::Eq(Span::new(eq.0, eq.2), e),
    <lo:@L> <delim:"open delim"> <hi:@R> => {
        let open = Span::new(lo, hi);
        let (tts, close) = cx.consume_delim(delim);
        AttrArgs::Delimited(DelimSpan::from_pair(open, close), delim, tts)
    }
}

AttrArgs: AttrArgs = {
    AttrArgsOpt? => <>.unwrap_or(AttrArgs::Empty),
}

OuterAttr: Attribute = {
    <lo:@L> "#" "[" <e:ExprPath> <args:AttrArgs> "]" <hi:@R> => {
        Attribute {
            id: DUMMY_ID,
            style: AttrStyle::Outer,
            kind: AttrKind::Normal(e, args),
            span: Span::new(lo, hi),
        }
    },
    <lo:@L> <doc:"outer doc"> <hi:@R> => Attribute {
        id: DUMMY_ID,
        style: AttrStyle::Outer,
        kind: AttrKind::Comment(doc.0, doc.1),
        span: Span::new(lo, hi),
    }
}

InnerAttr: () = {
    <lo:@L> "#" "!" "[" <e:ExprPath> <args:AttrArgs> "]" <hi:@R> => {
        cx.push_attr(Attribute {
            id: DUMMY_ID,
            style: AttrStyle::Inner,
            kind: AttrKind::Normal(e, args),
            span: Span::new(lo, hi),
        })
    },
    <lo:@L> <doc:"inner doc"> <hi:@R> => cx.push_attr(Attribute {
        id: DUMMY_ID,
        style: AttrStyle::Inner,
        kind: AttrKind::Comment(doc.0, doc.1),
        span: Span::new(lo, hi),
    }),
}

RangeLimits: RangeLimits = {
    ".." => RangeLimits::HalfOpen,
    "..=" => RangeLimits::Closed,
}

#[inline]
Attrs: Vec<Attribute> = OuterAttr*;

// ------------------------------------------
// Identifiers

Ident: Ident = {
    <lo:@L> <ident:"ident"> <hi:@R> =>? 
        ident::parse_ident(diag, Span::new(lo, hi), ident),
}

Lifetime: Lifetime = {
    <lo:@L> <lifetime:"lifetime"> <hi:@R> => Lifetime {
        id: DUMMY_ID,
        ident: Ident::new(lifetime, Span::new(lo, hi)),
    },
}

#[inline]
Mutability: Mutability = {
    "const"? => Mutability::kw(kw::CONST),
    "mut" => Mutability::kw(kw::MUT),
    "move" => Mutability::kw(kw::MOVE),
    "#" <ident:Ident> => Mutability { id: DUMMY_ID, ident },
}

// ------------------------------------------
// Expressions

Where: Vec<P<Expr>> = {
    "where" <first:Expr> <next:("," Expr)*> ","? => {
        [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect()
    },
}

Prerequisites: Prerequisites = {
    <lo:@L>
        "forall" <first:Ident> <next:("," Ident)*>
        <w:Where?> "::"
    <hi:@R> => {
        Prerequisites {
            id: DUMMY_ID,
            forall: [first].into_iter().chain(next.into_iter().map(|n| n.1)).collect(),
            where_clause: w.unwrap_or_default(),
            span: Span::new(lo, hi),
        }
    },
}

UnOpKind: UnOpKind = {
    "*" => UnOpKind::Deref,
    "!" => UnOpKind::Not,
    "-" => UnOpKind::Neg,
}

UnOp: UnOp = {
    <un:(@L UnOpKind @R)> => UnOp {
        kind: un.1,
        span: Span::new(un.0, un.2),
    },
}

ExprTupleField: TupleField = {
    <lo:@L> <prereq:Prerequisites?> <hi:@R> <attrs:Attrs> <e:Expr> => TupleField {
        prerequisites: prereq.unwrap_or_else(|| {
            Prerequisites::from_span(Span::new(lo, hi))
        }),
        attrs: cx.take_attr(attrs),
        visibility: Visibility {
            kind: VisibilityKind::Inherited,
            span: DUMMY_SPAN
        },
        expr: e,
    },
    <lo:@L> <prereq:Prerequisites?> <hi:@R>
        <attrs:Attrs>
        <vis:(@L Visibility @R)>
    <e:ExprPath> => TupleField {
        prerequisites: prereq.unwrap_or_else(|| {
            Prerequisites::from_span(Span::new(lo, hi))
        }),
        attrs: cx.take_attr(attrs),
        visibility: parse_vis(vis),
        expr: e,
    },
}

ExprTuple: P<Expr> = {
    <lo:@L> "(" ")" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Tuple(vec![]),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),
    <lo:@L> "(" <e:ExprTupleField> "," ")" <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Tuple(vec![e]),
            span: Span::new(lo, hi),
            attrs: vec![],
        })
    },
    <lo:@L> "("
        <first:ExprTupleField>
        <next:("," ExprTupleField)+>
        ","?
    ")" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Tuple(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),
}

ExprArray: P<Expr> = {
    <lo:@L> "[" "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Array(vec![]),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    <lo:@L> "[" <first:Expr> <next:("," Expr)*> ","? "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Array(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    <lo:@L> "[" <e:Expr> ";" <count:Expr> "]" <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::ArrayRepeated(e, count),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),
}

ExprAtomic: P<Expr> = {
    "(" <e:Expr> ")" => e,

    <ident:Ident> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Ident(ident),
        span: ident.span,
        attrs: vec![],
    }),

    <lit:(@L "literal" @R)> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Literal(lit.1),
        span: Span::new(lit.0, lit.2),
        attrs: vec![],
    }),
}

ExprPath: P<Expr> = {
    #[precedence(level = "0")]
    ExprAtomic,

    #[precedence(level = "1")] #[assoc(side = "left")]
    <e:ExprAtomic> <op:(@L "." @R)> <func:ExprAtomic> => {
        let span = Span::new(e.span.start, func.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::InfixCall(e, Span::new(op.0, op.2), func),
            span,
            attrs: vec![],
        })
    },
}

ExprDelimited: P<Expr> = {
    ExprPath,
    ExprTuple,
    ExprArray,
}

ExprUnary: P<Expr> = {
    #[precedence(level = "0")]
    ExprDelimited,

    <lo:@L> <un:UnOp> <e:ExprDelimited> <hi:@R> => {
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Unary(un, e),
            span: Span::new(lo, hi),
            attrs: vec![],
        })
    },

    <lo:@L> "&" <l:Lifetime?> <m:Mutability> <e:ExprUnary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::AddrOf(l, m, e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    #[precedence(level = "1")] #[assoc(side = "left")]
    <func:ExprUnary> <arg:ExprDelimited> => {
        let span = Span::new(func.span.start, arg.span.end);
        P(Expr {
            id: DUMMY_ID,
            kind: ExprKind::Call(func, arg),
            span,
            attrs: vec![],
        })
    },
}

ExprBinary: P<Expr> = {
    #[precedence(level = "0")]
    ExprUnary,

    #[precedence(level = "1")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "*"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Mul, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "/"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Div, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "%"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Rem, op.2), rhs),

    #[precedence(level = "2")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "+"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Add, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "-"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Sub, op.2), rhs),

    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "<<"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Shl, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">>"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Shr, op.2), rhs),

    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "^"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitXor, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "&"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitAnd, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "|"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::BitOr, op.2), rhs),

    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs:(@L ExprBinary?)> <r:RangeLimits> <rhs:(ExprBinary? @R)> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Range(lhs.1, r, rhs.0),
        span: Span::new(lhs.0, rhs.1),
        attrs: vec![],
    }),

    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "=="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Eq, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "!="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Ne, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Lt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Gt, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L "<="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Le, op.2), rhs),
    <lhs:(@L ExprBinary)> <op:(@L ">="  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Ge, op.2), rhs),

    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "&&"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::And, op.2), rhs),

    #[precedence(level = "8")] #[assoc(side="left")]
    <lhs:(@L ExprBinary)> <op:(@L "||"  @R)> <rhs:(ExprBinary @R)> =>
        expr::parse_bin(lhs, (op.0, BinOpKind::Or, op.2), rhs),
}

pub Expr: P<Expr> = {
    ExprBinary,

    <lo:@L> "try" <e:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Try(e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),

    <lo:@L> "exists" <e:ExprBinary> <hi:@R> => P(Expr {
        id: DUMMY_ID,
        kind: ExprKind::Exists(e),
        span: Span::new(lo, hi),
        attrs: vec![],
    }),
}

// ------------------------------------------
// Patterns

#[inline]
BindingMode: BindingMode = {
    "ref"? => match <> {
        Some(_) => BindingMode::ByRef,
        None => BindingMode::ByValue,
    }
}

PatTuple: P<Pat> = {
    <lo:@L> "(" ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(vec![]),
        span: Span::new(lo, hi),
    }),
    <lo:@L> "(" <e:PatAtomic> "," ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(vec![e]),
        span: Span::new(lo, hi),
    }),
    <lo:@L> "(" <first:PatAtomic> <next:("," PatAtomic)+> ","? ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Tuple(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
    }),
}

PatArray: P<Pat> = {
    <lo:@L> "[" "]" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Array(vec![]),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "[" <first:PatAtomic> <next:("," PatAtomic)*> ","? "]" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Array(
            [first]
                .into_iter()
                .chain(next.into_iter().map(|n| n.1))
                .collect()
        ),
        span: Span::new(lo, hi),
    }),
}

PatField: PatField = {
    <lo:@L>
        <attrs:Attrs>
        <i:@L> <mode:BindingMode> <m:Mutability> <ident:Ident>
    <hi:@R> => PatField {
        attrs: cx.take_attr(attrs),
        id: DUMMY_ID,
        ident,
        pat: pat::parse_ident(Span::new(i, hi), mode, m, ident),
        span: Span::new(lo, hi),
        is_shorthand: false,
        is_placeholder: false,
    },

    <lo:@L>
        <attrs:Attrs>
        <ident:Ident> "=" <pat:PatAtomic>
    <hi:@R> => PatField {
        attrs: cx.take_attr(attrs),
        id: DUMMY_ID,
        ident,
        pat,
        span: Span::new(lo, hi),
        is_shorthand: true,
        is_placeholder: false,
    },
}

PatStruct: P<Pat> = {
    <lo:@L> <ident:Ident> "{" "}" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Struct(ident, vec![]),
        span: Span::new(lo, hi),
    }),

    <lo:@L> <ident:Ident> "{"
        <first:PatField>
        <fields:(";" PatField)*> ";"?
    "}" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Struct(
            ident,
            vec![first]
                .into_iter()
                .chain(fields.into_iter().map(|n| n.1))
                .collect(),
        ),
        span: Span::new(lo, hi),
    }),

}

PatAtomic: P<Pat> = {
    <lo:@L> "(" <pat:Pat> ")" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Paren(pat),
        span: Span::new(lo, hi),
    }),

    <lo:@L> "_" <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Wildcard,
        span: Span::new(lo, hi)
    }),

    <lo:@L> <lit:"literal"> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Literal(lit),
        span: Span::new(lo, hi),
    }),

    PatArray,
    PatTuple,
    PatStruct,

}

PatOp: P<Pat> = {
    #[precedence(level = "0")]
    PatAtomic,

    #[precedence(level = "1")] #[assoc(side = "left")]
    <lhs:(@L PatOp?)> <r:RangeLimits> <rhs:(PatOp? @R)> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Range(lhs.1, r, rhs.0),
        span: Span::new(lhs.0, rhs.1),
    }),

    #[precedence(level = "2")]
    <lo:@L> "&" <l:Lifetime?> <m:Mutability> <i:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Deref(l, m, i),
        span: Span::new(lo, hi),
    }),

    #[precedence(level = "3")]
    <lo:@L>
        <i_lo:@L> <mode:BindingMode> <m:Mutability> <ident:Ident> <i_hi:@R>
        <alias:("@" PatOp)?>
    <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Ident(mode, m, ident, alias.map(|p| p.1)),
        span: Span::new(lo, hi)
    }),
}

pub Pat: P<Pat> = {
    PatOp,

    <lo:@L> <lhs:(PatOp "|")+> <rhs:PatOp> <hi:@R> => P(Pat {
        id: DUMMY_ID,
        kind: PatKind::Or(lhs.into_iter().map(|p| p.0).chain([rhs]).collect()),
        span: Span::new(lo, hi),
    }),
}

__unused: PhantomData<&'diag ()> = {
    <Ident> => PhantomData,
}
